rake dev:cache
if Rails.root.join('tmp/caching-dev.txt').exist?
  config.action_controller.perform_caching = true
  config.action_mailer.perform_caching = false
  config.cache_store = :memory_store
  config.public_file_server.headers = {
    'Cache-Control' => 'public, max-age=172800'
  }
else
  config.action_controller.perform_caching = false
  config.action_mailer.perform_caching = false
  config.cache_store = :null_store
end

- As someone once said, thank God if you are able to use page caching because it adds a huge boost to your app’s performance. The idea behind this technique is simple: the whole HTML page is saved to a file inside the public directory. On subsequent requests, this file is being sent directly to the user without the need to render the view and layout again.
- Unfortunately, such a powerful solution has very limited usage. If you have many pages that look different for different users, page caching is not the best option. Also, it cannot be employed in scenarios where your website may be accessed by authorized users only.
- only semistatic pages

gem 'actionpack-page_caching'
config.action_controller.page_cache_directory = "#{Rails.root.to_s}/public/deploy"
caches_page :index
expire_page action: 'index'

- Action caching works pretty much like page caching, however instead of immediately sending the page stored inside the public directory, it hits Rails stack. By doing this, it runs before actions that can, for example, handle authentication logic.

gem 'actionpack-action_caching'
caches_action :restricted
expire_page action: :restricted

Fragment caching, as the name implies, caches only the part of your page. This functionality exists in Rails’ core, so you don’t have to add it manually.
<% @products.each do |product| %>
  <% cache product do %>
    <%= product.title %>
  <% end %>
<% end %>
<% cache "products" do %>
  <%= render @products, cached: true %>
<% end %>
<!-- russain doll caching -->
expire_fragment(@product)

- Model caching (aka low level caching) is often used to cache a particular query, however, this solution can be employed to store any data. This functionality is also a part of Rails’ core.

class << self
  def all_cached
    Rails.cache.fetch("products") { Product.all }
  end
end

- The fetch method can both read and write Rails’ cache (the first argument is the storage’s name). If the requested storage is empty, it will be populated with the content specified inside the block. If it contains something, the result will simply be returned. There are also write and read methods available.

def index
  @products = Product.all_cached
end
after_commit :flush_cache

def flush_cache
  Rails.cache.delete('products')
end

- After any product is updated, we invalidate the “products” cache. Model caching is pretty simple to implement and can significantly speed up your complex queries.
- The last type of caching we are going to discuss today is HTTP caching that relies on HTTP_IF_NONE_MATCH and HTTP_IF_MODIFIED_SINCE headers. Basically, these headers are being sent by the client to check when the page’s content was last modified and whether its unique id has changed. This unique id is called an ETag and is generated by the server.
- The client receives an ETag and sends it inside the HTTP_IF_NONE_MATCH header on subsequent requests. If the ETag sent by the client does not match the one generated on the server, it means the page has been modified and needs to be downloaded again. Otherwise, a 304 (“not modified”) status code is returned and a browser uses a cached copy of the page.

def show
  @product = Product.find(params[:id])
  if stale?(last_modified: @product.updated_at.utc, etag: @product.cache_key)
    respond_to do |format|
      format.html
    end
  end
end

- The idea is simple – if the product was recently updated, the cache will be invalidated and the client will have to download the page once again. Otherwise, Rails will send a 304 status code. cache_key is a special method that generates a proper unique id for a record.

def show
  @product = Product.find(params[:id])
  if stale?(@product)
    respond_to do |format|
      format.html
    end
  end
end

- stale? will fetch the product’s timestamp and cache key automatically. fresh_when is a simpler method that can be used if you don’t want to utilize respond_to:

def show
  @product = Product.find(params[:id])
  fresh_when @product
end
